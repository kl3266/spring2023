diff --git a/lecture_10/Include/ISA.hh b/lecture_10/Include/ISA.hh
index f3247d1..31ce2b3 100644
--- a/lecture_10/Include/ISA.hh
+++ b/lecture_10/Include/ISA.hh
@@ -17,9 +17,12 @@
 
 // 2.2. Arithmetic instructions
 #define addi(RT, RA, SI)	instructions::addi::execute(RT, RA, SI, __LINE__)
+#define add(RT, RA, RS)	instructions::add::execute(RT, RA, RS, __LINE__)
+#define sub(RT, RA, RS)	instructions::sub::execute(RT, RA, RS, __LINE__)
 
 // 2.3. Compare instructions
 #define cmpi(RA, SI)		instructions::cmpi::execute(RA, SI, __LINE__)
+#define cmp(RA, RT)		instructions::cmp::execute(RA, RT, __LINE__)
 
 // 3. Floating-point Facility
 
diff --git a/lecture_10/Include/pipelined.hh b/lecture_10/Include/pipelined.hh
index 93e7615..ddc02e6 100644
--- a/lecture_10/Include/pipelined.hh
+++ b/lecture_10/Include/pipelined.hh
@@ -55,6 +55,11 @@ namespace pipelined
 	    extern const u32 	N;
 	};
 
+	namespace vector
+	{
+		const u32	VSIZE = 32;
+	}
+
 	namespace L1
 	{
 	    extern const u32	nsets;
@@ -226,14 +231,14 @@ namespace pipelined
 
     union vector
     {
-	u8	byte[16];
-	u16	half[8];
-	u32	word[4];
-	u64	dword[2];
-	float	sp[4];
-	double	dp[2];
-
-	vector&	operator=(int v) { for (u32 i=0; i<16; i++) byte[i] = v; return *this; }
+	u8	byte[params::vector::VSIZE];
+	u16	half[params::vector::VSIZE >> 1];
+	u32	word[params::vector::VSIZE >> 2];
+	u64	dword[params::vector::VSIZE >> 3];
+	float	sp[params::vector::VSIZE >> 2];
+	double	dp[params::vector::VSIZE >> 3];
+
+	vector&	operator=(int v) { for (u32 i=0; i<params::vector::VSIZE; i++) byte[i] = v; return *this; }
     };
 
     namespace VRF
@@ -322,7 +327,7 @@ namespace pipelined
 		void store	(u32 EA, double D);		// stores double-precision value D in address EA
 		void store	(u32 EA, u8	B);		// store byte B in address EA
 		void store	(u32 EA, const vector &V);	// store vector V in address EA
-		void store	(u32 EA, const u8 (&V)[16]);	// store bytes of vector V in address EA
+		void store	(u32 EA, const u8 (&V)[params::vector::VSIZE]);	// store bytes of vector V in address EA
         };
 
         typedef std::vector<entry>      set;
@@ -494,6 +499,66 @@ namespace pipelined
 		std::string dasm() { std::string str = "addi (p" + std::to_string(_idx) + ", p" + std::to_string(GPR[_RA].idx()) + ", " + std::to_string(_SI) + ")"; return str; }
 	};
 
+	class add : public operation
+	{
+	    private:
+		gprnum	_RT;
+		gprnum 	_RA;
+		gprnum	_RS;
+		u32	_idx;
+	    public:
+		add(gprnum RT, gprnum RA, gprnum RS) { _RT = RT; _RA = RA, _RS = RS; }
+		units::unit& unit() { return units::FXU; }
+		u64 target(u64 cycle) 
+		{ 
+		    GPR[_RT].busy() = false;
+		    _idx = PRF::find_next();
+		    return max(cycle, PRF::R[_idx].used());
+		}
+		bool issue(u64 cycle)
+		{
+		    GPR[_RA].used(cycle);
+			GPR[_RS].used(cycle);
+		    u32 RES = GPR[_RA].data() + GPR[_RS].data(); 
+		    GPR[_RT].idx()   = _idx; 
+		    GPR[_RT].data()  = RES;
+		    GPR[_RT].ready() = cycle + latency(); 
+		    return false; 
+		}
+		u64 ready() { return max(GPR[_RA].ready(), GPR[_RS].ready()); }
+		std::string dasm() { std::string str = "add (p" + std::to_string(_idx) + ", p" + std::to_string(GPR[_RA].idx()) + ", p" + std::to_string(GPR[_RS].idx()) + ")"; return str; }
+	};
+
+	class sub : public operation
+	{
+	    private:
+		gprnum	_RT;
+		gprnum 	_RA;
+		gprnum	_RS;
+		u32	_idx;
+	    public:
+		sub(gprnum RT, gprnum RA, gprnum RS) { _RT = RT; _RA = RA, _RS = RS; }
+		units::unit& unit() { return units::FXU; }
+		u64 target(u64 cycle) 
+		{ 
+		    GPR[_RT].busy() = false;
+		    _idx = PRF::find_next();
+		    return max(cycle, PRF::R[_idx].used());
+		}
+		bool issue(u64 cycle)
+		{
+		    GPR[_RA].used(cycle);
+			GPR[_RS].used(cycle);
+		    u32 RES = GPR[_RA].data() - GPR[_RS].data(); 
+		    GPR[_RT].idx()   = _idx; 
+		    GPR[_RT].data()  = RES;
+		    GPR[_RT].ready() = cycle + latency(); 
+		    return false; 
+		}
+		u64 ready() { return max(GPR[_RA].ready(), GPR[_RS].ready()); }
+		std::string dasm() { std::string str = "sub (p" + std::to_string(_idx) + ", p" + std::to_string(GPR[_RA].idx()) + ", p" + std::to_string(GPR[_RS].idx()) + ")"; return str; }
+	};
+
 	class cmpi : public operation
 	{
 	    private:
@@ -517,6 +582,30 @@ namespace pipelined
 		std::string dasm() { std::string str = "cmpi (p" + std::to_string(GPR[_RA].idx()) + ", " + std::to_string(_SI) + ")"; return str; }
 	};
 
+	class cmp : public operation
+	{
+	    private:
+		gprnum	_RA;
+		gprnum	_RT;
+	    public:
+		cmp(gprnum RA, gprnum RT) { _RA = RA; _RT = RT; }
+		bool issue(u64 cycle) 
+		{
+		    GPR[_RA].used(cycle);
+			GPR[_RT].used(cycle);
+		    flags.LT = false; flags.GT = false; flags.EQ = false;
+		    if      (GPR[_RA].data() < GPR[_RT].data()) flags.LT = true;
+        	    else if (GPR[_RA].data() > GPR[_RT].data()) flags.GT = true;
+        	    else                            flags.EQ = true;
+		    flags.ready = cycle + latency();
+		    return false; 
+		}	
+		units::unit& unit() { return units::FXU; }
+		u64 target(u64 cycle) { return cycle; }
+		u64 ready() { return max(GPR[_RA].ready(), GPR[_RT].ready()); }
+		std::string dasm() { std::string str = "cmp (p" + std::to_string(GPR[_RA].idx()) + ", p" + std::to_string(GPR[_RT].idx()) + ")"; return str; }
+	};
+
 	u8*	load( u32 EA, u32 L);
 
 	class lbz : public operation
@@ -684,9 +773,9 @@ namespace pipelined
 		{ 
 		    if(_latency) return _latency; 
 		    u32 EA = GPR[_RA].data(); 
-		    if      (caches::L1D.contains(EA,16))	_latency = params:: L1::latency;
-		    else if (caches:: L2.contains(EA,16))	_latency = params:: L2::latency;
-		    else if (caches:: L3.contains(EA,16)) 	_latency = params:: L3::latency;
+		    if      (caches::L1D.contains(EA,params::vector::VSIZE))	_latency = params:: L1::latency;
+		    else if (caches:: L2.contains(EA,params::vector::VSIZE))	_latency = params:: L2::latency;
+		    else if (caches:: L3.contains(EA,params::vector::VSIZE)) 	_latency = params:: L3::latency;
 		    else  					_latency = params::MEM::latency; 
 		    return _latency; 
 		}
@@ -701,15 +790,15 @@ namespace pipelined
 		{
 		    GPR[_RA].used(cycle);
 		    u32 EA = GPR[_RA].data(); 			// compute effective address of load
-		    u8* data = load(EA,16);			// fill the cache with the line, if not already there
+		    u8* data = load(EA,params::vector::VSIZE);			// fill the cache with the line, if not already there
 		    VR[_VT].idx()   = _idx;
-		    for (u32 i=0; i<16; i++) VR[_VT].data().byte[i] = *((u8*)data + i);
+		    for (u32 i=0; i<params::vector::VSIZE; i++) VR[_VT].data().byte[i] = *((u8*)data + i);		// write vector by byte.
 		    VR[_VT].ready() = cycle + latency(); 
 		    return false; 
 		}
 		u64 ready() { return max(GPR[_RA].ready()); }
 		std::string dasm() { std::string str = "vlb (q" + std::to_string(_idx) + ", p" + std::to_string(GPR[_RA].idx()) + ")"; return str; }
-		u64 cacheready() { u32 EA = GPR[_RA].data(); u64 ready; return caches::L1D.contains(EA,16, ready) ? ready : 0; }
+		u64 cacheready() { u32 EA = GPR[_RA].data(); u64 ready; return caches::L1D.contains(EA,params::vector::VSIZE, ready) ? ready : 0; }
 	};
 
 	class vstb : public operation
@@ -724,18 +813,18 @@ namespace pipelined
 		{
 		    GPR[_RA].used(cycle);
 		    uint32_t EA = GPR[_RA].data();				// compute effective address of store
-		    u8* data = load(EA,16);					// fill the cache with the line, if not already there
-		    caches::L1D.find(EA,16)->store(EA,VR[_VS].data().byte);	// write data to L1 cache
-		    caches::L2 .find(EA,16)->store(EA,VR[_VS].data().byte);	// write to L2 as well, since L1 is write-through!
+		    u8* data = load(EA,params::vector::VSIZE);					// fill the cache with the line, if not already there
+		    caches::L1D.find(EA,params::vector::VSIZE)->store(EA,VR[_VS].data().byte);	// write data to L1 cache
+		    caches::L2 .find(EA,params::vector::VSIZE)->store(EA,VR[_VS].data().byte);	// write to L2 as well, since L1 is write-through!
 		    return false; 
 		}
 		u32 latency() 
 		{ 
 		    if(_latency) return _latency; 
 		    u32 EA = GPR[_RA].data(); 
-		    if      (caches::L1D.contains(EA,16))	_latency = params:: L1::latency;
-		    else if (caches:: L2.contains(EA,16))	_latency = params:: L2::latency;
-		    else if (caches:: L3.contains(EA,16)) 	_latency = params:: L3::latency;
+		    if      (caches::L1D.contains(EA,params::vector::VSIZE))	_latency = params:: L1::latency;
+		    else if (caches:: L2.contains(EA,params::vector::VSIZE))	_latency = params:: L2::latency;
+		    else if (caches:: L3.contains(EA,params::vector::VSIZE)) 	_latency = params:: L3::latency;
 		    else  					_latency = params::MEM::latency; 
 		    return _latency; 
 		}
@@ -743,7 +832,7 @@ namespace pipelined
 		u64 target(u64 cycle) { return cycle; }
 		u64 ready() { return max(GPR[_RA].ready(), VR[_VS].ready()); }
 		std::string dasm() { std::string str = "vstb (q" + std::to_string(VR[_VS].idx()) + ", p" + std::to_string(GPR[_RA].idx()) + ")"; return str; }
-		u64 cacheready() { u32 EA = GPR[_RA].data(); u64 ready; return caches::L1D.contains(EA,16, ready) ? ready : 0; }
+		u64 cacheready() { u32 EA = GPR[_RA].data(); u64 ready; return caches::L1D.contains(EA,params::vector::VSIZE, ready) ? ready : 0; }
 	};
 
 	class b : public operation
@@ -958,6 +1047,32 @@ namespace pipelined
 		std::string dasm() { std::string str = "addi (r" + std::to_string(_RT) + ", r" + std::to_string(_RA) + ", " + std::to_string(_SI) + ")"; return str; }
 	};
 
+	class add : public instruction
+	{
+	    private:
+		gprnum	_RT;
+		gprnum	_RA;
+		gprnum	_RS;
+	    public:
+		add(gprnum RT, gprnum RA, gprnum RS, u32 addr) : instruction(addr) { _RT = RT; _RA = RA; _RS = RS; }
+		bool process() { return operations::process(new operations::add(_RT, _RA, _RS), dispatched()); }
+		static bool execute(gprnum RT, gprnum RA, gprnum RS, u32 line) { return instructions::process(new add(RT, RA, RS, 4*line)); }
+		std::string dasm() { std::string str = "add (r" + std::to_string(_RT) + ", r" + std::to_string(_RA) + ", r" + std::to_string(_RS) + ")"; return str; }
+	};
+
+	class sub : public instruction
+	{
+	    private:
+		gprnum	_RT;
+		gprnum	_RA;
+		gprnum	_RS;
+	    public:
+		sub(gprnum RT, gprnum RA, gprnum RS, u32 addr) : instruction(addr) { _RT = RT; _RA = RA; _RS = RS; }
+		bool process() { return operations::process(new operations::sub(_RT, _RA, _RS), dispatched()); }
+		static bool execute(gprnum RT, gprnum RA, gprnum RS, u32 line) { return instructions::process(new sub(RT, RA, RS, 4*line)); }
+		std::string dasm() { std::string str = "sub (r" + std::to_string(_RT) + ", r" + std::to_string(_RA) + ", r" + std::to_string(_RS) + ")"; return str; }
+	};
+
 	class cmpi : public instruction
 	{
 	    private:
@@ -970,6 +1085,18 @@ namespace pipelined
 		std::string dasm() { std::string str = "cmpi (r" + std::to_string(_RA) + ", " + std::to_string(_SI) + ")"; return str; }
 	};
 
+	class cmp : public instruction
+	{
+	    private:
+		gprnum	_RA;
+		gprnum	_RT;
+	    public:
+		cmp(gprnum RA, gprnum RT, u32 addr) : instruction(addr) { _RA = RA; _RT = RT; }
+		bool process() { return operations::process(new operations::cmp(_RA, _RT), dispatched()); }
+		static bool execute(gprnum RA, gprnum RT, u32 line) { return instructions::process(new cmp(RA, RT, 4*line)); }
+		std::string dasm() { std::string str = "cmp (r" + std::to_string(_RA) + ", r" + std::to_string(_RT) + ")"; return str; }
+	};
+
 	class lbz : public instruction
 	{
 	    private:
diff --git a/lecture_10/Include/vmemcpy.hh b/lecture_10/Include/vmemcpy.hh
index 0b103aa..3d2ba1f 100644
--- a/lecture_10/Include/vmemcpy.hh
+++ b/lecture_10/Include/vmemcpy.hh
@@ -3,7 +3,7 @@
 
 namespace pipelined
 {
-    void *vmemcpy(void *dest, const void *src, size_t n);
+    void *vmemcpy(void *dest, const void *src, size_t n, u32 v_size);
 };
 
 #endif
diff --git a/lecture_10/Src/pipelined.cc b/lecture_10/Src/pipelined.cc
index 067ed8c..a869627 100644
--- a/lecture_10/Src/pipelined.cc
+++ b/lecture_10/Src/pipelined.cc
@@ -12,17 +12,17 @@ namespace pipelined
     const u32 	params::L1::latency = 2;
     const u32	params::L1::nsets = 16;
     const u32 	params::L1::nways = 4;
-    const u32	params::L1::linesize = 16;
+    const u32	params::L1::linesize = params::vector::VSIZE;
 
     const u32 	params::L2::latency = 4;
     const u32	params::L2::nsets = 64;
     const u32 	params::L2::nways = 4;
-    const u32	params::L2::linesize = 16;
+    const u32	params::L2::linesize = params::vector::VSIZE;
 
     const u32 	params::L3::latency = 8;
     const u32	params::L3::nsets = 64;
     const u32 	params::L3::nways = 16;
-    const u32	params::L3::linesize = 16;
+    const u32	params::L3::linesize = params::vector::VSIZE;
 
     const u32	params::GPR::N = 16;
     const u32 	params::FPR::N = 8;
@@ -514,13 +514,13 @@ namespace pipelined
 	modified = true;
     }
 
-    void pipelined::caches::entry::store(u32 EA, const u8 (&V)[16])
+    void pipelined::caches::entry::store(u32 EA, const u8 (&V)[params::vector::VSIZE])
     {
 	u32 offset = EA % data.size();
 	assert(offset == 0);
 	assert(sizeof(V) == data.size());
 	u8 *buff = (u8*)(data.data() + offset);
-	for (u32 i=0; i<16; i++) *((u8*)buff + i) = V[i];
+	for (u32 i=0; i<params::vector::VSIZE; i++) *((u8*)buff + i) = V[i];
 	modified = true;
     }
 
diff --git a/lecture_10/Src/vmemcpy.cc b/lecture_10/Src/vmemcpy.cc
index 0b62088..e691215 100644
--- a/lecture_10/Src/vmemcpy.cc
+++ b/lecture_10/Src/vmemcpy.cc
@@ -8,17 +8,17 @@ namespace pipelined
     (
         void            *dest,  // GPR[3]
         const void      *src,   // GPR[4]
-        size_t           n      // GPR[5]
+        size_t           n, u32 v_size    // GPR[5] v_size  // GPR[8]
     )
     {
         addi(r7, r3, 0);        // preserve GPR[3] so that we can just return it
-loop:	cmpi(r5,16);		// n == 16?
-	blt(remain);		// while(n >= 16)
+loop:	cmp(r5, r8);		// n == v_size?
+	blt(remain);		// while(n >= v_size)
 	vlb(v0, r4);		// load vector of bytes from *src
 	vstb(v0, r7);		// store vector of bytes to *dest
-	addi(r4, r4, 16);	// src += 16
-	addi(r7, r7, 16);	// dest += 16
-	addi(r5, r5, -16);	// n -= 16
+	add(r4, r4, r8);	// src += v_size
+	add(r7, r7, r8);	// dest += v_size
+	sub(r5, r5, r8);	// n -= v_size
 	b(loop);		// end while
 remain: cmpi(r5, 0);            // n == 0?
         beq(end);               // while(n != 0)
diff --git a/lecture_10/Tests/vmemcpy.cc b/lecture_10/Tests/vmemcpy.cc
index c411f6e..46e7492 100644
--- a/lecture_10/Tests/vmemcpy.cc
+++ b/lecture_10/Tests/vmemcpy.cc
@@ -19,8 +19,9 @@ int main
 
     pipelined::zeromem();
     const uint32_t N = 1024;
+	const uint32_t VSIZE = 32;
     for (uint32_t i=0; i<N; i++) pipelined::MEM[i] = rand() % 0xff;
-    for (uint32_t n = 1; n<=N; n *= 2)
+    for (uint32_t n = 3; n<=N; n *= 2)
     {
 	pipelined::zeroctrs();
 	for (uint32_t i=0; i<n; i++) pipelined::MEM[N+i] = 0;
@@ -28,8 +29,9 @@ int main
 	pipelined::GPR[3].data() = N;
 	pipelined::GPR[4].data() = 0;
 	pipelined::GPR[5].data() = n;
+	pipelined::GPR[8].data() = VSIZE;
 	
-	pipelined::vmemcpy(0,0,0);
+	pipelined::vmemcpy(0,0,0,0);
 
 	pipelined::caches::L2.flush();
 	pipelined::caches::L3.flush();
@@ -37,8 +39,8 @@ int main
 	double rate = (double)pipelined::counters::cycles/(double)n;
 	
 	if (pipelined::tracing) printf("\n");
-	printf("n = %6d : instructions = %6lu, cycles = %6lu, L1D accesses= %6lu, L1D hits = %6lu",
-		n, pipelined::counters::operations, pipelined::counters::cycles, pipelined::caches::L1D.accesses, pipelined::caches::L1D.hits);
+	printf("n = %6d, VSIZE = %6d : instructions = %6lu, cycles = %6lu, L1D accesses= %6lu, L1D hits = %6lu", n,
+		VSIZE, pipelined::counters::operations, pipelined::counters::cycles, pipelined::caches::L1D.accesses, pipelined::caches::L1D.hits);
 	printf(", cyc/B = %10.2f", rate);
 
 	bool pass = true;
